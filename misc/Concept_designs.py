# -*- coding: utf-8 -*-
"""
Created on Wed May 15 09:44:48 2019

@author: msjor
"""
############################################# Imports #################################################
import numpy as np

############################################# Functions ###############################################

def panel_area(t_o, t_e, pr_day, pr_eclipse, theta = 0):
    """t_o = orbital time [sec]
        t_e = eclipse time [sec]
        pr_day = power required during the day [W]
        pr_eclipse = power required during eclipse [W]
        theta = incidence angle [rad]"""

    #Mission parameters
    t_d = t_o - t_e #day time [s]
    T = 10 #mission lifetime [years]
    sr = 1358 #solar radiation [W/m^2]

    #efficiencies
    eff = 0.28 #solar panel efficiency
    eff_c = 0.9 #path efficiency panels to equipments
    eff_dc = 0.85 #path efficiency panels through batteries to equipment

    #solar panel characterisitcs
    wkg = 100 #[W/kg]
    d = 0.9725 #yearly degradation

    #compute required powerzzzz during day and eclipse
    pr_day = pr_day/eff_c #power required during the day EOL [W]
    pr_eclipse = pr_eclipse/eff_dc #power required during eclipse EOL [W]

    #EQUATIONS
    pbol = ((pr_day*t_d+pr_eclipse*t_e)/(t_d)/(d**T))/np.cos(theta) #bol power accounting for degradation, eclipse time, incidence angle

    psol = pbol/eff #power that needs to be generated by solar panels accounting for their efficiency

    #compute area and mass of panels
    A = psol/sr #area
    m = pbol/wkg #mass

    return A, m

def comms_mass(power_transmitter, area_antenna, dens_antenna):
   """power_transmitter = power required by the transmitter on the spacecraft [W]
       Area of the antenna [m^2]
       dens_antenna = density of the antenna [kg/m^3], typical values of the """
   specific_power = 2.9 #W/kg
   dens_trans = 0.75*10**-3 #kg/m3
   mass_trans = power_transmitter/specific_power  #kg
   vol_trans = mass_trans/dens_trans  #m3

   #mass of the amplifier
   mass_amp = 0.07*power_transmitter+0.634 #kg

   #Antenna characterisics
   mass_antenna = dens_antenna * area_antenna #kg, antenna on board of spacecraft

   #Combine to find mass total communications system
   total_mass = (mass_antenna + mass_amp + mass_trans)*1.3

   return total_mass, vol_trans

def orbit(lower_limit, upper_limit, B, rho, T, D, sun_sync, N=720):
    """Calculates orbit data.

    For a circular orbit, the lower and upper limit should be the same. The
    output variables are the same no matter the orbit type, but in the case of
    a circular orbit, some output variables will be the same (e.g. semi-major
    axis, apocentre radius and pericentre radius)

    In the case of an elliptical orbit, r and V_orb will be arrays of N
    entries, where N is the number of steps into which the orbit is divided.

    An inclination will only be calculated for a sun-synchronous orbit, as it
    is not unique for a different orbit.

    INPUT:
        lower_limit = lowest orbital altitude [km]
        upper_limit = highest orbital altitude [km]
        B           = ballistic coefficient [kg/m^2]
        rho         = density [kg/m^3]
        T           = Thrust [N]
        D           = Drag [N]
        sun_sync    = sun-synchronous orbit [True or False]

    OUTPUT:
        a           = semi-major axis [km]
        r_a         = appocentre radius [km]
        r_p         = pericentre radius [km]
        r           = orbital radius [km]
        V_orb       = orbital velocity [km/s]
        P_orb       = orbital period [s]
        T_ecl       = eclipse time [s] (first order crude estimate)
        delta_V_tot = required delta V per orbit for station keeping [m/s]
        i_deg       = inclination [deg] (sun-synchronous orbits only)
    """
    ## constants

    # Earth data
    R_e         = 6378.1           # km, Earth's radius
    g_0         = 0.00981          # km/s^2, Earth's surface gravity
    mu          = 398600.44        # km^3/s^2, Earth's gravitational constant
    G_e         = 6.6725*10**(-11) # Nm^2/kg, universal gravitational constant
    P_ES        = 365.25 * 86400   # s, period of Earth around the sun
    J_2         = 1082 * 1e-6      # ?, J2 effect in gravity field

    ## calculations, for the formulas, see AE2230 equations by heart and
    ## lecture slides.
    theta  = np.linspace(0, 2*np.pi, N)              # rad, orbit angle
    a      = (lower_limit + upper_limit + 2 * R_e)/2 # km, semi-major axis
    r_a    = upper_limit + R_e                       # km, appocentre r
    r_p    = lower_limit + R_e                       # km, pericentre r
    e      = r_a/a - 1                               # -, eccentricity
    r      = a * (1 - e*e) / (1 + e * np.cos(theta)) # km, orbit radius
    h      = r - R_e                                 # km, orbit height
    n      = 2 * np.pi / T_orb # s^-1, mean motion
    V_orb  = np.sqrt( mu * ( (2/r) - (1/a) ) )       # km/s, orbital V
    P_orb  = 2 * np.pi * np.sqrt(a**3 / mu)          # s, orbital period
    E_tot  = -mu / (2 * a) * 1e6                     # J/kg, specific energy
    T_ecl  = np.arcsin(R_e / a) * P_orb              # s, eclipse time (first order estimate (2D, sun at inf, circular orb))

    # required delta V for station keeping per orbit (formula from SMAD)
    Per         = P_orb / (3600 * 24 * 365) # yr, period
    delta_T_tot = (theta/n)[np.where( T < D )] # s, time when T < D
    delta_T = np.hstack( (np.diff(delta_T_tot[np.where(delta_T_tot < T_orb/
              2)]), np.diff(delta_T_tot[np.where(delta_T_tot > T_orb/2)]) ) )

    loss_part = np.where(np.logical_or(delta_T_tot < T_orb/2, delta_T_tot > T_orb/2))
    delta_V_req = np.pi * (1/B) * rho * (r * V_orb * 1e6) / Per # m/s/yr
    delta_V_mss = delta_V_req / (3600 * 24 * 365)               # m/s/s
    delta_V_tot = sum( delta_V_mss[loss_part][1:-1] * delta_T ) # m/s, total

    if sun_sync:
        # inclination for a syn-synchronous orbit, see AE2230 slide 1 p. 57
        i     = np.arccos(-2/3 * P_orb/P_ES * 1/(J_2 * (R_e / r_p)**2)) # rad
        i_deg = np.rad2deg(i) # deg

        return a, r_a, r_p, r, e, V_orb, P_orb, T_ecl, delta_V_tot, i_deg

    return a, r_a, r_p, r, e, V_orb, P_orb, T_ecl, delta_V_tot

def comms(h, freq, G_trans, D_reciever, Ts, R, E_N):
    """Link budget in order to calculate the power required for the transmitter
    h = altitude [km]
    freq = frequency used for communication [Hz]
    G_trans = gain of the transmitting antenna of the spacecraft [dB]
    D_reciever = diameter of the recieving antenna [m]
    Ts = system noise temperature [K]
    R = data rate during communications [bps]
    E_N = signal to noise ratio [dB]"""

    #Characterisics of the system
    dish_eff = 0.5  #efficiency of the dish of the recieving station

    #Losses and gains
    line = 0.89     #line losses [dB]
    rain = 4+3/13*(freq*10**(-9)-27)    #rain attentuation losses [dB], TO BE ADAPTED FOR ALL f
    space = 147.55-20*np.log10(h*10**3)-20*np.log10(freq)   #space losses [dB]
    G_rec = -159.59+20*np.log10(D_reciever)+20*np.log10(freq)+10*np.log10(dish_eff) #gain of the recieving antenna [dB]
    G_trans = G_trans

    return 10**((E_N-line-G_trans-space-rain-G_rec-228.6+10*np.log10(Ts)+10*np.log10(R))/10)

def thrust_power(T):
    """Compute the power required to provide a certain thrust for RIT ion thruster
        T = thrust [N]"""
    #returns the power required [W] based on a linear relation between thrust and power
    return (T+0.00069068)/0.0000156

def power_thrust(P):
    """Compute the thrust created at a certain power setting for RIT ion thruster
    P = power [W]"""
    #returns the thrust provided [N] based on a linear relation between thrust and power
    return -0.00069068+0.0000156*P

def CD_cylinder(A):
    """"Compute C_D of a cylinder in a rarified flow
        A = frontal area [m^2]"""
    CD = (1.+np.pi/6.*np.sqrt(A/np.pi))*2
    return CD

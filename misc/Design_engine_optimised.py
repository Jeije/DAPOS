# -*- coding: utf-8 -*-
"""
Created on Fri May 10 09:47:33 2019

@author: msjor
"""

import numpy as np
import matplotlib.pyplot as plt
from Iterated_drag_surface import Drag_Thrust_Area_iteration

############################    Functions   ############################
#instead of import from power in src folder, as import doesn't work 
def panel_area(t_o, t_e, pr_day, pr_eclipse):
    #INPUTS
    wm = 200 #[W/m^2] not really needed as we are mainly concerned with solar radiation and panel efficiencies
    wkg = 80 #[W/kg]
    #t_o = 14095 #orbital period in [s]
    #t_e = 5920 #eclipse time [s]
    t_d = t_o - t_e #day time [s]
    sr = 1400 #solar radiation [W/m^2]
    theta = 0 #solar panel incidence angle [rad]
    T = 10 #mission lifetime [years]
    d = 0.99 #yearly degradation
    eff = 0.28 #solar panel efficiency
    eff_c = 0.99 #battery charging efficiency
    eff_dc = 0.99 #battery discharging efficiency
    #pr_day = 500 #power required during the day EOL [W]
    pr_eclipse = pr_eclipse/eff_c/eff_dc #power required during eclipse EOL [W]
    
    #EQUATIONS
    pbol = ((pr_day*t_d+pr_eclipse*t_e)/(t_d)/(d**T))/np.cos(theta) #bol power accounting for degradation, eclipse time, incidence angle
    
    psol = pbol/eff #power that needs to be generated by solar panels accounting for their efficiency
    
    A = psol/sr #area
    m = psol/wkg #mass
    
    #print('power =', psol, 'A=', A, 'm =', m)
    
    return A, m

#area to drag and power relations 
def A_to_Drag(A):
    return density*(velocity**2)*(1.+np.pi/6.)*np.sqrt(A/np.pi)*A

def Drag_to_A(D):
    return np.cbrt((D/(density*velocity**2*(1+np.pi/6)))**2*np.pi)

def thrust_to_A(T):
    return T/(density*velocity*intake_eff*Isp*9.81)

def A_to_thrust(A):
    return density*A*velocity*intake_eff*Isp*9.81

def panel_drag(A_p):
    return 0.3*A_p*0.5*density*velocity**2

def area_panel_drag(D_p):
    return D_p*2/0.3/density/velocity**2

def comms(h, freq, G_trans, D_reciever, Ts, R):
    dish_eff = 0.55
    rain = 4+3/13*(freq*10**-9-27)
    space = 147.55-20*np.log10(h*10**3)-20*np.log10(freq)
    G_rec = -159.59+20*np.log10(D_reciever)+20*np.log10(freq)+10*np.log10(dish_eff)
    line = 0.89
    G_trans = G_trans
    E_N = 7
    
    return 10**((E_N-line-G_trans-space-rain-G_rec-228.6+10*np.log10(Ts)+10*np.log10(R))/10)

################################    main     #############################
#define orbit parameters 
t_o = 3600*1.5  #orbital period
t_e = 36.9*60   #eclipse period
h = 225   #orbital altitude #[km]
density = 1*10**-10  #[kg/m^3]
velocity = 7800 #[m/s]

#propulsion parameters
Isp = 3546 #[s]
intake_eff = 0.4    #[-]
thrust_power = 64*10**3   #[W/N]
area_correction = 1.1
T_over_D = 1.05

#communication parameters 
freq = 36 #communication frequency [GHz]
freq = freq*10**9 #communications frequency [Hz]
G_trans = 15 #gain satellite antenna [dBi]
D_reciever = 1.5 #diameter reciever on ground [m]
Ts = 600 #system noise temperature [K]
datarate_imaging = 2632*10**6 #[bps]
compression_rat = 3/5   #[-]
data_orbit = datarate_imaging*(t_o-t_e)*compression_rat     #data produced during orbit [bits]
contact_time = 0.015*t_o       #[s]
R = data_orbit/contact_time    #data rate [bps]

#1Mb/s 

#find intake area, drag/thrust, massflow and power required for engine
A, F, mdot, power_engine = Drag_Thrust_Area_iteration(Isp, density, intake_eff, velocity, thrust_power)

#find power required for communication system 
P_comm = comms(h, freq, G_trans, D_reciever, Ts, R)

#power needed for other subsystems (from power budget)
P_camera = 10.
#define power requirments
power_day = power_engine+ P_comm +P_camera
power_eclipse = power_engine

#find maximum panel area and mass based on power requirments and orbit parameters 
panel_A, panel_mass = panel_area(t_o, t_e, power_day, power_eclipse)

print ("Intake surface area (maximum) =", A, "[m^2]")
print ("Panel surface area (for max intake) = ", panel_A, "[m^2]")
print ("Thrust provided (for max intake) = ", F,  "[N]")
print ("power used by engine (for max intake) = ", power_engine, "[W]")
print ("power used by communication system = ", P_comm, "[W]")


#indentify range of possible intake areas and plot results for entire range
A_i = 0.
A_range = []
power_range = []
panelA_range = []
panelM_range = []
drag_range = []
thrust_range = []
massf_range = []

while A_i<=A:
    #compute forces for different possible areas of intake
    drag_i = A_to_Drag(A_i*area_correction)
    thrust_i = A_to_thrust(A_i)
    
    #compute engine powers required at respective intake areas
    power_i = thrust_i*thrust_power
    
    #define day and night power
    power_day_i = power_i +P_comm+P_camera
    power_eclipse_i = power_i
    
    #compute panel area and mass needed for different intake areas
    panelA_i, panelm_i =panel_area(t_o, t_e, power_day_i, power_eclipse_i)
    drag_panel_i = panel_drag(panelA_i)
    
    while np.abs((drag_i+drag_panel_i)*T_over_D-thrust_i)>0.0000001:
        #compensate thrust for additonal drag created by the panels
        thrust_tot = (drag_panel_i+drag_i)*T_over_D
        #find ned power required to find new thrust
        power_day = thrust_tot*thrust_power+P_comm+P_camera
        power_eclipse = thrust_tot*thrust_power
        #find ned panel area and mass needed for providing the needed power
        panelA, panelM = panel_area(t_o, t_e, power_day, power_eclipse)
        
        #add new panel drag and thrust for iteration
        drag_panel_i= panel_drag(panelA)
        thrust_i = thrust_tot

    massf_range.append(A_i*density*velocity*intake_eff) 
    A_range.append(A_i)
    drag_range.append(drag_i+drag_panel_i)
    thrust_range.append(thrust_i)
    power_range.append(thrust_i*thrust_power/1000)
    panelA_range.append(panelA)
    panelM_range.append(panelM)
    A_i+=0.25
    
plt.plot(A_range, power_range, "green", label="power [W] vs intake area [m^2]")
plt.plot(A_range, panelA_range, "black", label = "panel area [m^2] vs intake area [m^2]")
plt.legend()
plt.show()

plt.plot(A_range, drag_range, "red", label = "drag [N] vs intake area [m^2]")
plt.plot(A_range, thrust_range, "blue", label = "thrust [N] vs intake area [m^2]")
plt.legend()
plt.show()

plt.plot(panelA_range, drag_range, "yellow", label = "drag [N] vs solar panel area [m^2]")
plt.plot(panelA_range, thrust_range, "orange", label = "thrust [N] vs solar panel area [m^2]")
plt.legend()
plt.show()
    

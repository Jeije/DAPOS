# -*- coding: utf-8 -*-
"""
Created on Fri May 10 09:47:33 2019

@author: msjor
"""

import numpy as np
import matplotlib.pyplot as plt
from Iterated_drag_surface import Drag_Thrust_Area_iteration

############################    Functions   ############################
#instead of import from power in src folder, as import doesn't work 
def panel_area(t_o, t_e, pr_day, pr_eclipse):
    #INPUTS
    wm = 200 #[W/m^2] not really needed as we are mainly concerned with solar radiation and panel efficiencies
    wkg = 80 #[W/kg]
    #t_o = 14095 #orbital period in [s]
    #t_e = 5920 #eclipse time [s]
    t_d = t_o - t_e #day time [s]
    sr = 1400 #solar radiation [W/m^2]
    theta = 0 #solar panel incidence angle [rad]
    T = 10 #mission lifetime [years]
    d = 0.99 #yearly degradation
    eff = 0.28 #solar panel efficiency
    eff_c = 0.99 #battery charging efficiency
    eff_dc = 0.99 #battery discharging efficiency
    #pr_day = 500 #power required during the day EOL [W]
    pr_eclipse = pr_eclipse/eff_c/eff_dc #power required during eclipse EOL [W]
    
    #EQUATIONS
    pbol = ((pr_day*t_d+pr_eclipse*t_e)/(t_d)/(d**T))/np.cos(theta) #bol power accounting for degradation, eclipse time, incidence angle
    
    psol = pbol/eff #power that needs to be generated by solar panels accounting for their efficiency
    
    A = psol/sr #area
    m = psol/wkg #mass
    
    #print('power =', psol, 'A=', A, 'm =', m)
    
    return A, m

#area to drag and power relations 
def A_to_Drag(A):
    return density*(velocity**2)*(1.+np.pi/6.)*np.sqrt(A/np.pi)*A

def Drag_to_A(D):
    return np.cbrt((D/(density*velocity**2*(1+np.pi/6)))**2*np.pi)

def thrust_to_A(T):
    return T/(density*velocity*intake_eff*Isp*9.81)

def A_to_thrust(A):
    return density*A*velocity*intake_eff*Isp*9.81


################################    main     #############################
#input values s/c
Isp = 3546 #[s]
density = 1*10**-10  #[kg/m^3]
intake_eff = 0.4    #[-]
velocity = 7800 #[m/s]
thrust_power = 70*10**3   #[W/N]


#find surface area, drag/thrust, massflow and power required for engine
A, F, mdot, power_engine = Drag_Thrust_Area_iteration(Isp, density, intake_eff, velocity, thrust_power)

#define power requirments
power_day = power_engine
power_eclipse = power_engine

#define orbit parameters 
t_o = 3600*1.5
t_e = 36.9*60

#find maximum panel area and mass based on power requirments and orbit parameters 
panel_A, panel_mass = panel_area(t_o, t_e, power_day, power_eclipse)

print ("Intake surface area (maximum) =", A, "[m^2]")
print ("Panel surface area (for max intake) = ", panel_A, "[m^2]")
print ("Thrust provided (for max intake) = ", F,  "[N]")
print ("power used by engine (for max intake) = ", power_engine, "[W]")

#indentify range of possible intake areas and plot results for entire range

A_i = 0.
A_range = []
power_range = []
panelA_range = []
panelM_range = []
while A_i<=A:
    #compute forces for different possible areas of intake
    drag_i = A_to_Drag(A_i)
    thrust_i = A_to_thrust(A_i)
    
    #compute engine powers required at respective intake areas
    power_i = thrust_i*thrust_power
    
    #define day and night power
    power_day = power_i
    power_eclipse = power_i
    
    #compute panel area and mass needed for different intake areas
    panelA_i, panelm_i =panel_area(t_o, t_e, power_day, power_eclipse)
    A_range.append(A_i)
    power_range.append(power_i/1000)
    panelA_range.append(panelA_i)
    panelM_range.append(panelm_i)
    A_i+=0.25
    
plt.plot(A_range, power_range, "green")
plt.plot(A_range, panelA_range, "black")
plt.show()
    
